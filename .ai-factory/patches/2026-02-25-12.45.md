# Deduplicate stuck_status: publish once per stuck set, not every loop

**Date:** 2026-02-25 12:45
**Files:** mqtt_layer.py, sms2mqtt.py, tests/test_received_publish.py
**Severity:** medium

## Problem

Topic `{prefix}/stuck_status` was receiving the same message every second while an incomplete multipart SMS was present (e.g. received_parts: 1, expected_parts: 2). Main loop runs ~1 s and each iteration called `loop_sms_receive`, which published `stuck_status` again for the same set of locations â€” flooding the topic.

## Root Cause

In `loop_sms_receive`, whenever an incomplete multipart was detected we set `stuck_sms_detected`, filled `last_stuck_sms`, and **always** published to `stuck_status`. There was no check whether this exact stuck set had already been reported. So the same "stuck" state was re-announced on every poll.

## Solution

- Added `ctx.last_stuck_locations` (tuple of sorted locations) to remember the last published stuck set.
- Publish `stuck_status` only when `locations != last_stuck_locations` (new or changed set).
- Reset `last_stuck_locations` when: (1) no stuck SMS in this run (end of loop), (2) after `delete_stuck_sms` clears the stuck list.
- Log with `[FIX]` when we actually publish stuck_status once per set.

## Prevention

- When publishing "state" events that can repeat every loop, consider publishing only on transition or change (e.g. by comparing with last-published value).
- Add test: call `loop_sms_receive` twice with same incomplete multipart mock; assert `stuck_status` is published only once.

## Tags

`#stuck_status` `#multipart` `#mqtt` `#dedupe` `#python`
